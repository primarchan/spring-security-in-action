# SPRING SECURITY in Action - Laurentiu Spilca, 2022

## 1장. 오늘날의 보안
- 스프링 시큐리티는 스프링 애플리케이션을 보호하기 위한 가장 인기있는 선택이며, 다양한 스타일과 아키텍처에 적용할 수 있는 갖가지 대안을 제공한다.
- 시스템의 계층별로 보안을 적용해야 하며, 계층별로 다른 관행을 이용해야 한다.
- 보안은 소프트웨어 프로젝트를 시작할 때부터 고려해야 하는 공통 관심사이다.
- 일반적으로 취약성를 예방하는 투자 비용보다 공격의 대가가 훨씬 크다.
- 오픈 웹 애플리케이션 보안 프로젝트(OWASP) 는 취약성과 보안 과련 ㅎ사항을 참고할 수 있는 훌륭한 장소다.
- 종종 아주 작은 실수 때문에 큰 피해가 발생한다. 예를 들어 로그나 오류 메시지에 민간한 데이터를 노출하는 것은 애플리케이션에 취약성을 만드는 흔한 실수다.

## 2장. Hello! Spring security
- 스프링 시큐리티를 애플리케이션의 종속성으로 추가하면 스프링 부트가 약간의 기본 구성를 제공한다.
- 인증과 권한 부여를 위한 기본 구성요소인 `UserDetailService`, `PasswordEncoder`, `AuthenticationProvider` 를 구현했다.
- `User 클래스`로 사용자를 정의할 수 있다. 사용자는 사용자 이름, 암호, 권한을 가져야 한다. 권한은 사용자가 애플리케이션의 컨텍스트에서 수행할 수 있는 작업을 지정한다.
- 스프링 시큐리티는 `UserDetailService` 의 간단한 구현인 `InMemoryUserDetailsManager` 를 제공한다. `UserDetailsService` 의 인스턴스와 같은 사용자를 추가해서 애플리케이션의 메모리에서 사용자를 관리할 수 있다.
- `NoOpPasswordEncoder` 는 `PasswordEncoder` 계약을 구현하며, 암호를 일반 텍스트로 처리한다. 이 구현은 학습 예제와 개념 증명에 적합하지만, 운영 단계 애플리케이션에는 적합하지 않다.
- `AuthenticationProvider` 계약을 이용해 애플리케이션의 맞춤형 인증 논리를 구현할 수 있다.
- 구성을 작성하는 방법은 여러 가지가 있지만, 한 애플리케이션에서는 한 방법을 선택하고 고수해야 코드를 깔끔하고 이해하기 쉽게 만들 수 있다.

## 3장. 사용자 관리
- `UserDetails` 인터페이스 스프링 시큐리티에서 사용자를 기술하는 데 이용되는 계약이다.
- `UserDetailsService` 인터페이스는 애플리케이션이 사용자 세부 정보를 얻는 방법을 설명하기 위해 스프링 시큐리티의 인증 아키텍처에서 구현해야 하는 계약이다.
- `UserDetailManager` 인터페이스는 `UserDetailService` 를 확장하고, 사용자 생성, 변경, 삭제와 관련된 동작을 추가한다.
- 스프링 시큐리티는 `UserDetailManager` 계약의 여러 구현을 제공한다. 이러한 구현에는 `InMemoryUserDetailManager`, `JdbcUserDetailManager`, `LdapUserDetailManager` 가 있다.
- `JdbcUserDetailManager` 는 JDBC 를 직접 이용하므로 애플리케이션이 다른 프레임워크에 고정되지 않는다는 이점이 있다.

## 4장. 암호 처리
- `PasswordEncoder` 는 인증 논리에서 암호를 처리하는 가장 중요한 책임을 담당한다.
- 스프링 시큐리티는 해싱 알고리즘에 여러 대안을 제공하므로 필요한 구현을 선택하기만 하면 된다.
- 스프링 시큐리티 `암호화 모듈(SSCM)` 에는 키 생성기와 암호기를 구현하는 여러 대안이 있다.
- 키 생성기는 암호화 알고리즘에 이용되는 키를 생성하도록 도와주는 유틸리티 객체이다.
- 암호기는 데이터 암호화와 복호화를 보와주는 유틸리티 객체이다.

## 5장. 인증 구현
- `AuthenticationProvider` 구성 요소를 이용하면, 맞춤형 인증 논리를 구현할 수 있다.
- 맞춤형 인증 논리를 구현할 때는 책임을 분리하는 것이 좋다. `AuthenticationProvider` 는 사용자 관리는 `UserDetailsService` 에 위임하고 암호 검증 책임은 `PasswordEncoder` 에 위임한다.
- `SecurityContext` 는 인증이 성공한 후, 인증된 엔티티에 대한 세부 정보를 유지한다.
- `SecurityContext` 를 관리하는 데는 `MODE_THREADLOCAL`, `MODE_INHERITABLETHREADLOCAL`, `MODE_GLOBAL` 의 세가지 전략을 이용할 수 있으며, 선택한 전략에 따라 다른 스레드에서 `SecurityContext` 세부 정보에 접근하는 방법이 달라진다.
- 공유 스레드 로컬 전략을 사용할 때는, 스프링이 관리하는 스레드에만 전략이 적용된다는 것을 기억하자. 프레임워크는 자신이 관리하지 않는 스레드에는 `SecurityContext` 를 복사하지 않는다.
- 스프링 시큐리티는 코드에서 생성했지만, 프레임워크가 인식한 스레드를 관리할 수 있는 우수한 유틸리티 클래스를 제공한다. 코드에서 생성한 스레드의 `SecurityContext` 를 관리하기 위해 다음 클래스를 이용할 수 있다.
  - `DelegatingSecurityContextRunnable`
  - `DelegationSecurityContextCallable`
  - `DelegationSecurityContextExecutor`
- 스프링 시큐리티는 양식 기반 로그인 인증 메서드인 `formLogin()` 으로 로그인 양식과 로그아웃하는 옵션을 자동으로 구성한다. 작은 웹 애플리케이션의 경우 직관적으로 이용할 수 있다.
- `formLogin()` 인증 메서드는 세부적으로 맞춤 구성이 가능하며, `HTTP Basic 방식`과 함께 이용해 두인증 유형을 모두 지원할 수도 있다.

## 6장. 실전: 작고 안전안 웹 애플리케이션
- 실제 애플리케이션에서는 같은 개념의 다른 구현이 필요한 종속성이 흔하게 이용된다. 이 예제에서는 스프링 시큐리티의 `UserDetails` 와 `JPA` 구현의 `User 엔티티`가 이러한 사례에 해당하며, 이때는 책임을 다른 클래스로 분리해 가독성을 높이는 것이 좋다.
- 대부분은 같은 기능을 여러 가지 다른 방법으로 구현할 수 있으며, 가장 단순한 해결책을 선택해야 한다. 코드를 이해하기 쉽게 만들면 오류와 보안 침해의 여지가 줄어든다.

## 7장. 권한 부여 구성: 엑세스 제한
- 권한 부여는 애플리케이션이 인증된 요청을 허가할지 결정하는 프로세스다. 권한 부여는 항상 인증 이후에 수행된다.
- 애플리케이션이 인증된 사용자의 권한과 역할에 따라 권한을 부여하는 방법을 구성할 수 있다.
- 애플리케이션이 인증되지 않은 사용자가 특정 요청을 수행할 수 있게 지정할 수도 있다.
- `denyAll()` 메서드로 앱이 모든 요청을 거부하고 `permitAll()` 메서드로 모든 요청을 수락하게 할 수 있다.

## 8장. 권한 부여 구성: 제한 적용
- 실제 시나리오에서는 요청마다 다른 권한 부여 규칙을 적용하는 경우가 많다.
- 경로와 HTTP 방식에 따라 권한 부여 규칙을 구성할 요청을지정한다. 이를 위해 MVC, 앤트, 정규식의  세 가지 선택기 매서드를 이용하는 방법을 배운다.
- MVC 와 앤트 선택기는 서로 비슷하며 일반적으로 이 중 하나를 선택해 권한 부여 제한을 적용할 요청을 지정할 수 있다.
- 요구 사항이 앤트나 MVC 식으로 해결하기에 너무 복잡할 때는 이보다 강력한 정규식으로 구현할 수 있다.
  - 정규식은 읽기 어렵고 상당히 길어질 수 있으므로 마지막 수단으로 남겨 두는 것이 좋다. MVC 와 앤트 식으로 문제를 해결할 수 없을 때만 정규식을 이용하자.

## 9장. 필터 구현
- 